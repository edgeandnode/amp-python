# generated by datamodel-codegen:
#   filename:  registry_openapi.json
#   timestamp: 2025-11-18T02:00:39+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Optional

from pydantic import AwareDatetime, BaseModel, Field, field_validator

from .validators import parse_utc_datetime


class ArchiveDatasetVersionResponse(BaseModel):
    """
    Response for archiving a dataset version
    """

    reference: Annotated[
        str,
        Field(
            description='The reference of the archived dataset version',
            examples=['edgeandnode/eth_transfers@1.0.0'],
        ),
    ]


class DatasetVersionAncestry(BaseModel):
    dataset_reference: Annotated[
        str,
        Field(
            description='Dataset reference in the format: {namespace}/{name}@{version_tag}. Points to the DatasetVersion.dataset_reference. This allows version-pinned dependencies.',
            examples=[
                'edgeandnode/eth_transfers@1.0.0',
                'edgeandnode/eth_transfers@8e0acc0',
                'edgeandnode/eth_transfers@latest',
            ],
            pattern='^[a-z0-9_]+/[a-z_][a-z0-9_]*@[a-z0-9._-]+$',
        ),
    ]


class DatasetVersionStatus(Enum):
    draft = 'draft'
    published = 'published'
    deprecated = 'deprecated'
    archived = 'archived'


class DatasetVisibility(Enum):
    private = 'private'
    public = 'public'


class ErrorResponse(BaseModel):
    """
    Standard error response returned by the API

    This struct represents error information returned in HTTP error responses.
    It provides structured error details including a machine-readable error code
    and human-readable message.

    ## Error Code Conventions
    - Error codes use SCREAMING_SNAKE_CASE (e.g., `DATASET_NOT_FOUND`)
    - Codes are stable and can be relied upon programmatically
    - Messages may change and should only be used for display/logging

    ## Example JSON Response
    ```json
    {
      "error_code": "DATASET_NOT_FOUND",
      "error_message": "dataset 'eth_mainnet' version '1.0.0' not found",
      "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
    }
    ```
    """

    error_code: Annotated[
        str,
        Field(
            description='Machine-readable error code in SCREAMING_SNAKE_CASE format\n\nError codes are stable across API versions and should be used\nfor programmatic error handling. Examples: `INVALID_SELECTOR`,\n`DATASET_NOT_FOUND`, `REGISTRY_DB_ERROR`'
        ),
    ]
    error_message: Annotated[
        str,
        Field(
            description='Human-readable error message\n\nMessages provide detailed context about the error but may change\nover time. Use `error_code` for programmatic decisions.'
        ),
    ]
    request_id: Annotated[
        Optional[str],
        Field(
            description='Request ID for tracing and correlation\n\nThis ID can be used to correlate error responses with server logs\nfor debugging and support purposes. The ID is generated per-request\nand appears in both logs and error responses.'
        ),
    ] = None


class HealthcheckResponse(BaseModel):
    status: str
    version: str


class LivenessResponse(BaseModel):
    status: str


class ManifestKind(Enum):
    manifest = 'manifest'
    evm_rpc = 'evm-rpc'
    eth_beacon = 'eth-beacon'
    firehose = 'firehose'


class ManifestTag(BaseModel):
    created_at: Annotated[
        str,
        Field(
            description='Timestamp when the ManifestTag record was created (immutable).'
        ),
    ]
    dataset_reference: Annotated[
        str,
        Field(
            description='Dataset reference in the format: {namespace}/{name}@{version_tag}. This value is globally unique and is a pointer to a tagged and published Manifest.',
            examples=[
                'edgeandnode/eth_transfers@1.0.0',
                'edgeandnode/eth_transfers@8e0acc0',
                'edgeandnode/eth_transfers@latest',
            ],
            pattern='^[a-z0-9_]+/[a-z_][a-z0-9_]*@[a-z0-9._-]+$',
        ),
    ]
    manifest: Optional[ManifestTag] = None
    name: Annotated[
        str,
        Field(
            description='The dataset name. Pattern: lowercase, underscores allowed, alphanumeric, cannot start with a number.',
            pattern='^[a-z_][a-z0-9_]*$',
        ),
    ]
    namespace: Annotated[
        str,
        Field(
            description='The dataset namespace. This is the logical/enforced grouping mechanism for datasets. It can be the user 0x address that deployed the subgraph, a chosen username, or org.',
            examples=[
                'edgeandnode',
                'testuser.eth',
                '0x85F036b4952B74A438d724EA93495FD6220B94b6',
            ],
            pattern='^[a-z0-9_]*$',
        ),
    ]
    version_tag: Annotated[
        str,
        Field(
            description="The published version tag. This is basically the version label. Can be semver, a commit hash, or 'latest'.",
            examples=['1.0.0', '0.1.0', '0.0.1', '8e0acc0', 'latest'],
            pattern='^[a-z0-9._-]+$',
        ),
    ]


class SavedQuery(BaseModel):
    created_at: Annotated[
        AwareDatetime,
        Field(
            description='Timestamp when the SavedQuery was created',
            examples=['2025-01-15T10:30:00Z'],
        ),
    ]
    creator: Annotated[
        str,
        Field(
            description='Creator/owner of the saved query (ethereum address or user_id)',
            examples=['0x1234567890123456789012345678901234567890'],
        ),
    ]
    description: Annotated[
        Optional[str],
        Field(
            description='Optional description of what the query does',
            examples=['Query to get all Ethereum transfers'],
        ),
    ] = None
    id: Annotated[
        str,
        Field(
            description='Unique identifier for the saved query (UUID)',
            examples=['123e4567-e89b-12d3-a456-426614174000'],
            pattern='^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$',
        ),
    ]
    name: Annotated[
        str,
        Field(description='Name of the saved query', examples=['Get all transfers']),
    ]
    query: Annotated[
        str,
        Field(
            description='The SQL query string',
            examples=['SELECT * FROM eth_transfers LIMIT 100'],
        ),
    ]
    updated_at: Annotated[
        AwareDatetime,
        Field(
            description='Timestamp when the SavedQuery was last updated',
            examples=['2025-01-15T14:45:00Z'],
        ),
    ]
    visibility: DatasetVisibility

    # Custom validator for datetime parsing
    _parse_datetimes = field_validator('created_at', 'updated_at', mode='before')(parse_utc_datetime)


class ServiceStatus(BaseModel):
    error: Optional[str] = None
    status: str


class UpdateDatasetMetadataDto(BaseModel):
    """
    Input for update the Datasets metadata fields:
    - keywords
    - README
    - sources
    - repository_url
    - license
    - description
    """

    description: Annotated[Optional[str], Field(description='Dataset description')] = (
        None
    )
    indexing_chains: Annotated[
        list[str], Field(description='Chains being indexed by the dataset')
    ]
    keywords: Annotated[
        Optional[list[str]], Field(description='Keywords for dataset discovery')
    ] = None
    license: Annotated[
        Optional[str], Field(description='License covering the dataset')
    ] = None
    readme: Annotated[
        Optional[str], Field(description='User-defined README for the dataset')
    ] = None
    repository_url: Annotated[
        Optional[str], Field(description='VCS repository URL')
    ] = None
    source: Annotated[
        Optional[list[str]], Field(description='Source of data being materialized')
    ] = None


class UpdateDatasetVersionStatusDto(BaseModel):
    """
    Input for updating a DatasetVersion's status
    """

    status: Annotated[
        DatasetVersionStatus,
        Field(
            description='The new status for the dataset version (Draft or Published)\nNote: Use the DELETE endpoint to archive a version'
        ),
    ]


class UpdateDatasetVisibilityDto(BaseModel):
    """
    Input for updating a Dataset's visibility
    """

    visibility: Annotated[
        DatasetVisibility, Field(description='The new visibility level for the dataset')
    ]


class DatasetVersion(BaseModel):
    ancestors: Annotated[
        Optional[list[DatasetVersionAncestry]],
        Field(
            description='Array of ancestor DatasetVersion references that this version extends from (version-pinned dependencies).'
        ),
    ] = None
    changelog: Annotated[
        Optional[str],
        Field(
            description='A description of what changed with this version. Allows developers of the Dataset to communicate to downstream consumers what has changed with this version from previous versions. Migration guides, etc.',
            examples=[
                'Version 1.0.0 - Added new features and bug fixes',
                'Breaking change: Updated schema structure',
            ],
        ),
    ] = None
    created_at: Annotated[
        str,
        Field(
            description='Timestamp when the DatasetVersion record was created (immutable).',
            examples=['2025-01-15T10:30:00Z'],
        ),
    ]
    dataset_reference: Annotated[
        str,
        Field(
            description='Dataset reference in the format: {namespace}/{name}@{version_tag}. This value is globally unique and is a pointer to a tagged and published Manifest.',
            examples=[
                'edgeandnode/eth_transfers@1.0.0',
                'edgeandnode/eth_transfers@8e0acc0',
                'edgeandnode/eth_transfers@latest',
            ],
            pattern='^[a-z0-9_]+/[a-z_][a-z0-9_]*@[a-z0-9._-]+$',
        ),
    ]
    descendants: Annotated[
        Optional[list[DatasetVersionAncestry]],
        Field(
            description='Array of descendant DatasetVersion references that extend from this version.'
        ),
    ] = None
    status: DatasetVersionStatus
    version_tag: Annotated[
        str,
        Field(
            description="The published version tag. This is basically the version label. Can be semver, a commit hash, or 'latest'.",
            examples=['1.0.0', '0.1.0', '0.0.1', '8e0acc0', 'latest'],
            pattern='^[a-z0-9._-]+$',
        ),
    ]


class DatasetWithScore(BaseModel):
    """
    Dataset with search relevance score. Extends the base Dataset with a weighted score indicating how well it matches the search query. Higher scores indicate better relevance.
    """

    created_at: Annotated[
        AwareDatetime,
        Field(
            description='Timestamp when the Dataset record was created (immutable).',
            examples=['2024-01-15T10:30:00Z'],
        ),
    ]
    dataset_reference: Annotated[
        Optional[str],
        Field(
            description='Computed link to the latest DatasetVersion reference in PURL format.',
            examples=['edgeandnode/eth_transfers@1.0.0'],
            min_length=1,
            pattern='^[a-z0-9_]+/[a-z_][a-z0-9_]*@[a-z0-9._-]+$',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Description of the dataset, its intended use, and purpose.',
            examples=['Ethereum ERC20 token transfers indexed from mainnet'],
            max_length=1024,
        ),
    ] = None
    indexing_chains: Annotated[
        list[str],
        Field(
            description='Chains being indexed by the Dataset. Used for discovery by chain.',
            examples=[['mainnet', 'arbitrum-one']],
        ),
    ]
    keywords: Annotated[
        Optional[list[str]],
        Field(
            description='User-defined or derived keywords defining the usage of the dataset.',
            examples=[['ERC20', 'DeFi', 'transfers']],
        ),
    ] = None
    latest_version: Optional[DatasetVersion] = None
    license: Annotated[
        Optional[str],
        Field(
            description='Usage license covering the Dataset.',
            examples=['MIT', 'Apache-2.0'],
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description='The dataset name. Lowercase, alphanumeric with underscores. Cannot start with a number.',
            examples=['eth_transfers', 'nft_marketplace', 'defi_protocol'],
            min_length=1,
            pattern='^[a-z_][a-z0-9_]*$',
        ),
    ]
    namespace: Annotated[
        str,
        Field(
            description='The dataset namespace. Logical grouping mechanism for datasets. Can be a user 0x address, username, or organization.',
            examples=[
                'edgeandnode',
                'testuser.eth',
                '0x85F036b4952B74A438d724EA93495FD6220B94b6',
            ],
            min_length=1,
            pattern='^[a-z0-9_]*$',
        ),
    ]
    owner: Annotated[
        str,
        Field(
            description='Owner of the Dataset. Can be an organization or user 0x address.',
            examples=['0x85F036b4952B74A438d724EA93495FD6220B94b6'],
        ),
    ]
    readme: Annotated[
        Optional[str],
        Field(
            description='User-defined README for the Dataset providing usage examples and documentation.',
            examples=[
                '# ETH Transfers\\n\\nThis dataset indexes all Ethereum transfers...'
            ],
        ),
    ] = None
    repository_url: Annotated[
        Optional[str],
        Field(
            description='VCS repository URL containing the Dataset source code.',
            examples=['https://github.com/edgeandnode/platform'],
        ),
    ] = None
    score: Annotated[
        float,
        Field(
            description='Weighted relevance score indicating how well this dataset matches the search query. Higher scores indicate better relevance. Score is calculated based on matches in description, keywords, source, and indexing chains fields.',
            examples=[0.95, 0.72, 0.45],
        ),
    ]
    source: Annotated[
        Optional[list[str]],
        Field(
            description='Source of data being materialized by the Dataset (e.g., contract addresses, logs, transactions).',
            examples=[['0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984']],
        ),
    ] = None
    updated_at: Annotated[
        AwareDatetime,
        Field(
            description='Timestamp when the Dataset record was last updated.',
            examples=['2024-01-20T14:45:00Z'],
        ),
    ]
    versions: Annotated[
        Optional[list[DatasetVersion]],
        Field(
            description='Link to all DatasetVersion records that this Dataset is a parent of.'
        ),
    ] = None
    visibility: DatasetVisibility

    # Custom validator for datetime parsing
    _parse_datetimes = field_validator('created_at', 'updated_at', mode='before')(parse_utc_datetime)


class InsertDatasetVersion(BaseModel):
    """
    Input for creating a new DatasetVersion. Contains the version tag, manifest hash, and manifest content.
    """

    changelog: Annotated[
        Optional[str],
        Field(
            description='Optional changelog describing what changed in this version.',
            examples=[
                'Added new features and bug fixes',
                'Breaking change: Updated schema structure',
            ],
        ),
    ] = None
    kind: ManifestKind
    manifest: Annotated[
        dict[str, Any],
        Field(
            description='Manifest JSON content. This should be a valid datasets_derived::Manifest structure. The SHA256 hash will be calculated server-side.',
            examples=[{'tables': [], 'version': '1.0'}],
        ),
    ]
    status: DatasetVersionStatus
    version_tag: Annotated[
        str,
        Field(
            description="Version tag (e.g., '1.0.0', 'latest', '8e0acc0'). Pattern: lowercase, numbers, dots, underscores, hyphens.",
            examples=['1.0.0', '0.1.0', '8e0acc0', 'latest'],
            pattern='^[a-z0-9._-]+$',
        ),
    ]


class Manifest(BaseModel):
    created_at: Annotated[
        str,
        Field(
            description='Timestamp when the `Manifest` record was created (immutable).',
            examples=['2025-01-15T10:30:00Z'],
        ),
    ]
    kind: ManifestKind
    manifest_hash: Annotated[
        str,
        Field(
            description='The SHA256 unique hash that represents that Manifest JSON content.',
            examples=[
                'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
            ],
            pattern='^[0-9a-fA-F]{64}$',
        ),
    ]


class ReadinessChecks(BaseModel):
    database: ServiceStatus


class ReadinessResponse(BaseModel):
    checks: ReadinessChecks
    status: str


class Dataset(BaseModel):
    """
    Top-level container for a user-defined, tagged, and published Dataset. Contains metadata and discovery information for datasets.
    """

    created_at: Annotated[
        AwareDatetime,
        Field(
            description='Timestamp when the Dataset record was created (immutable).',
            examples=['2024-01-15T10:30:00Z'],
        ),
    ]
    dataset_reference: Annotated[
        Optional[str],
        Field(
            description='Computed link to the latest DatasetVersion reference in PURL format.',
            examples=['edgeandnode/eth_transfers@1.0.0'],
            min_length=1,
            pattern='^[a-z0-9_]+/[a-z_][a-z0-9_]*@[a-z0-9._-]+$',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='Description of the dataset, its intended use, and purpose.',
            examples=['Ethereum ERC20 token transfers indexed from mainnet'],
            max_length=1024,
        ),
    ] = None
    indexing_chains: Annotated[
        list[str],
        Field(
            description='Chains being indexed by the Dataset. Used for discovery by chain.',
            examples=[['mainnet', 'arbitrum-one']],
        ),
    ]
    keywords: Annotated[
        Optional[list[str]],
        Field(
            description='User-defined or derived keywords defining the usage of the dataset.',
            examples=[['ERC20', 'DeFi', 'transfers']],
        ),
    ] = None
    latest_version: Optional[DatasetVersion] = None
    license: Annotated[
        Optional[str],
        Field(
            description='Usage license covering the Dataset.',
            examples=['MIT', 'Apache-2.0'],
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description='The dataset name. Lowercase, alphanumeric with underscores. Cannot start with a number.',
            examples=['eth_transfers', 'nft_marketplace', 'defi_protocol'],
            min_length=1,
            pattern='^[a-z_][a-z0-9_]*$',
        ),
    ]
    namespace: Annotated[
        str,
        Field(
            description='The dataset namespace. Logical grouping mechanism for datasets. Can be a user 0x address, username, or organization.',
            examples=[
                'edgeandnode',
                'testuser.eth',
                '0x85F036b4952B74A438d724EA93495FD6220B94b6',
            ],
            min_length=1,
            pattern='^[a-z0-9_]*$',
        ),
    ]
    owner: Annotated[
        str,
        Field(
            description='Owner of the Dataset. Can be an organization or user 0x address.',
            examples=['0x85F036b4952B74A438d724EA93495FD6220B94b6'],
        ),
    ]
    readme: Annotated[
        Optional[str],
        Field(
            description='User-defined README for the Dataset providing usage examples and documentation.',
            examples=[
                '# ETH Transfers\n\nThis dataset indexes all Ethereum transfers...'
            ],
        ),
    ] = None
    repository_url: Annotated[
        Optional[str],
        Field(
            description='VCS repository URL containing the Dataset source code.',
            examples=['https://github.com/edgeandnode/platform'],
        ),
    ] = None
    source: Annotated[
        Optional[list[str]],
        Field(
            description='Source of data being materialized by the Dataset (e.g., contract addresses, logs, transactions).',
            examples=[['0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984']],
        ),
    ] = None
    updated_at: Annotated[
        AwareDatetime,
        Field(
            description='Timestamp when the Dataset record was last updated.',
            examples=['2024-01-20T14:45:00Z'],
        ),
    ]
    versions: Annotated[
        Optional[list[DatasetVersion]],
        Field(
            description='Link to all DatasetVersion records that this Dataset is a parent of.'
        ),
    ] = None
    visibility: DatasetVisibility

    # Custom validator for datetime parsing
    _parse_datetimes = field_validator('created_at', 'updated_at', mode='before')(parse_utc_datetime)


class DatasetListResponse(BaseModel):
    datasets: Annotated[
        list[Dataset],
        Field(description='List of the datasets being returned in this page'),
    ]
    has_next_page: Annotated[
        bool, Field(description='If true, there are more datasets that can be fetched')
    ]
    total_count: Annotated[
        int, Field(description='Total number of datasets matching the query filters')
    ]


class DatasetSearchResponse(BaseModel):
    datasets: Annotated[
        list[DatasetWithScore],
        Field(description='List of the datasets being returned in this page'),
    ]
    has_next_page: Annotated[
        bool, Field(description='If true, there are more datasets that can be fetched')
    ]
    total_count: Annotated[
        int, Field(description='Total number of datasets matching the query filters')
    ]


class InsertDataset(BaseModel):
    """
    Input for creating a new Dataset. Contains metadata, discovery information, and the initial version to create. The owner will be automatically set to the authenticated user.
    """

    description: Annotated[
        Optional[str],
        Field(
            description='Description of the dataset, its intended use, and purpose.',
            examples=['Ethereum ERC20 token transfers indexed from mainnet'],
            max_length=1024,
        ),
    ] = None
    indexing_chains: Annotated[
        list[str],
        Field(
            description='Chains being indexed by the Dataset. Used for discovery by chain.',
            examples=[['mainnet', 'arbitrum-one']],
        ),
    ]
    keywords: Annotated[
        Optional[list[str]],
        Field(
            description='User-defined keywords defining the usage of the dataset.',
            examples=[['ERC20', 'DeFi', 'transfers']],
        ),
    ] = None
    license: Annotated[
        Optional[str],
        Field(
            description='Usage license covering the Dataset.',
            examples=['MIT', 'Apache-2.0', 'GPL-3.0'],
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description='The dataset name. Pattern: lowercase, alphanumeric with underscores, cannot start with a number.',
            examples=['eth_transfers', 'nft_marketplace', 'defi_protocol'],
            min_length=1,
            pattern='^[a-z_][a-z0-9_]*$',
        ),
    ]
    namespace: Annotated[
        str,
        Field(
            description='The dataset namespace. Pattern: lowercase, numbers, underscores.',
            examples=['edgeandnode', 'testuser_eth', 'my_org'],
            min_length=1,
            pattern='^[a-z0-9_]*$',
        ),
    ]
    readme: Annotated[
        Optional[str],
        Field(
            description='User-defined README for the Dataset providing usage examples and documentation.',
            examples=[
                '# ETH Transfers\\n\\nThis dataset indexes all Ethereum transfers...'
            ],
        ),
    ] = None
    repository_url: Annotated[
        Optional[str],
        Field(
            description='VCS repository URL containing the Dataset source code.',
            examples=['https://github.com/edgeandnode/platform'],
            pattern='^https?://[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(/.*)?$',
        ),
    ] = None
    source: Annotated[
        Optional[list[str]],
        Field(
            description='Source of data being materialized by the Dataset (e.g., contract addresses).',
            examples=[['0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984']],
        ),
    ] = None
    version: InsertDatasetVersion
    visibility: DatasetVisibility


class OwnerDatasetListResponse(BaseModel):
    datasets: Annotated[
        list[Dataset],
        Field(description='List of the datasets being returned in this page'),
    ]
    has_next_page: Annotated[
        bool, Field(description='If true, there are more datasets that can be fetched')
    ]
    total_count: Annotated[
        int, Field(description='Total number of datasets matching the query filters')
    ]


class AuthUserOwnedDatasetListResponse(BaseModel):
    datasets: Annotated[
        list[Dataset],
        Field(description='List of the datasets being returned in this page'),
    ]
    has_next_page: Annotated[
        bool, Field(description='If true, there are more datasets that can be fetched')
    ]
    total_count: Annotated[
        int, Field(description='Total number of datasets matching the query filters')
    ]


ManifestTag.model_rebuild()
